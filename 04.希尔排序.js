let arr = [35, 33, 42, 10, 14, 19, 27, 44]
let result = shellSort(arr)
console.log(result);

function shellSort(arr) {
  let len = arr.length,
    temp,
    gap = 1;

  while (gap < len / 3) {
    gap = gap * 3 + 1;
  }

  for (gap; gap > 0; gap = Math.floor(gap / 3)) {
    for (let i = gap; i < len; i++) {
      temp = arr[i];
      let j = i - gap;
      for (; j >= 0 && arr[j] > temp; j -= gap) {
        arr[j + gap] = arr[j];
      }
      arr[j + gap] = temp;
    }
  }

  return arr;
}

// 思路
/* 
先将整个待排序的记录序列分割成为若干子序列。
分别进行直接插入排序。
待整个序列中的记录基本有序时，再对全体记录进行依次直接插入排序。 
*/

/* 
例：arr=[35, 33, 42, 10, 14, 19, 27, 44]
1.我们采取间隔 4。创建一个位于 4 个位置间隔的所有值的虚拟子列表。下面这些值是 { 35, 14 }，{ 33, 19 }，{ 42, 27 } 和 { 10, 44 }。
2.我们比较每个子列表中的值，并在原始数组中交换它们（如果需要）。完成此步骤后，数组=[14, 19, 27, 10,35, 33, 42, 44]。
3.然后，我们采用 2 的间隔，这个间隙产生两个子列表：{ 14, 27, 35, 42 }， { 19, 10, 33, 44 }，但是我们判断交换时，其实是用{14,27},{19,10},{27,42},{33,44}来判断。
4.我们比较并交换原始数组中的值（如果需要）。完成此步骤后，数组变成：[14, 10, 27, 19, 35, 33, 42, 44]。
5.最后，我们使用值间隔 1 对数组的其余部分进行排序。
*/

{
  let arr = [35, 33, 42, 10, 14, 19, 27, 44]
  let len = arr.length,
    temp,
    gap = 1;

  while (gap < len / 3) {
    //动态定义间隔序列
    gap = gap * 3 + 1;
  }

  // 根据上面的思路，我们把{ 35, 14 }中的35称为间隔1, 14称为间隔2
  for (gap; gap > 0; gap = Math.floor(gap / 2)) {//最外层循环，根据分割次数循环，直到gap=1 （这里可以除以2也可以除以3。除以2 gap依次取值4,2,1；除以3 gap依次取值4,1）
    for (let i = gap; i < len; i++) {//第二层循环，根据gap长度循环
      temp = arr[i];//拿到间隔2的值
      let j = i - gap;//间隔1值的索引
      //最内层循环，用于作判断，只会循环一次，
      // 如果间隔1值>间隔2的值,会执行下方替换操作，然后把间隔1值的索引设为 j -= gap
      for (; j >= 0 && arr[j] > temp; j -= gap) {
        arr[j + gap] = arr[j];//间隔2的值=间隔1值
      }
      //两种情况：
      // 一、如果执行了上面的内循环 间隔1的值=间隔2的值(注意此时 j 经过内层循环后等于-gap，所以此时 j + gap 是间隔1的索引) 
      // 二、如果没有执行上面的内循环 间隔2的值=间隔2的值，相当于没有做操作
      arr[j + gap] = temp;
    }
  }
}